sudo mysql
CREATE DATABASE Library;
USE Library;


ایجاد جدول ها در دیتابیس بر اساس کلاس هایی که در کد موجود هست:






CREATE TABLE user (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE
);


CREATE TABLE library_item (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author VARCHAR(150) NOT NULL,
    publish_date DATE NOT NULL,
    status ENUM('BANNED', 'BORROWED', 'EXIST') NOT NULL DEFAULT 'EXIST',
    type ENUM('BOOK', 'MAGAZINE', 'THESIS', 'REFERENCE') NOT NULL,
    return_date DATE,
    user_id INT NULL,  
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE SET NULL
);


CREATE TABLE book (
    item_id INT PRIMARY KEY,
    isbn VARCHAR(20) NOT NULL,
    genre VARCHAR(100) NOT NULL,
    page_count INT NOT NULL,
    FOREIGN KEY (item_id) REFERENCES library_item(id) ON DELETE CASCADE
);

CREATE TABLE magazine (
    item_id INT PRIMARY KEY,
    issue_number VARCHAR(20) NOT NULL,
    publisher VARCHAR(150) NOT NULL,
    category VARCHAR(100) NOT NULL,
    FOREIGN KEY (item_id) REFERENCES library_item(id) ON DELETE CASCADE
);

CREATE TABLE reference (
    item_id INT PRIMARY KEY,
    reference_type VARCHAR(100) NOT NULL,
    edition VARCHAR(50) NOT NULL,
    subject VARCHAR(150) NOT NULL,
    FOREIGN KEY (item_id) REFERENCES library_item(id) ON DELETE CASCADE
);

CREATE TABLE thesis (
    item_id INT PRIMARY KEY,
    university VARCHAR(150) NOT NULL,
    department VARCHAR(100) NOT NULL,
    advisor VARCHAR(150) NOT NULL,
    FOREIGN KEY (item_id) REFERENCES library_item(id) ON DELETE CASCADE
);


CREATE TABLE history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    item_id INT NOT NULL,
    user_id INT NOT NULL,
    borrowed_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (item_id) REFERENCES library_item(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);



در این بخش دیتا هایی را وارد جداول میکنیم تا روی آن ها query ها را بزنیم و خروجی را بررسی کنیم:



INSERT INTO user (username) VALUES 
('john_doe'),
('jane_smith'),
('alice_wong'),
('bob_brown');

INSERT INTO library_item (title, author, publish_date, status, type) VALUES
('The Great Gatsby', 'F. Scott Fitzgerald', '1925-04-10', 'EXIST', 'BOOK');

INSERT INTO book (item_id, isbn, genre, page_count) VALUES 
(1, '9780743273565', 'Fiction', 180);


INSERT INTO library_item (title, author, publish_date, status, type, user_id, return_date) VALUES
('To Kill a Mockingbird', 'Harper Lee', '1960-07-11', 'BORROWED', 'BOOK', 1, 
 DATE_ADD(CURDATE(), INTERVAL 14 DAY));

ININSERT INTO book (item_id, isbn, genre, page_count) VALUES 
(LAST_INSERT_ID(), '9780061120084', 'Fiction', 281);

INSERT INTO library_item (title, author, publish_date, status, type) VALUES
('National Geographic', 'Various Editors', '2024-03-01', 'EXIST', 'MAGAZINE');

INSERT INTO magazine (item_id, issue_number, publisher, category) VALUES 
(3, 'March 2024', 'National Geographic Society', 'Science');


ININSERT INTO library_item (title, author, publish_date, status, type, user_id, return_date) VALUES
('Science Today', 'Science Editorial', '2024-02-15', 'BORROWED', 'MAGAZINE', 2,
 DATE_ADD(CURDATE(), INTERVAL 14 DAY));

INSERT INTO magazine (item_id, issue_number, publisher, category) VALUES 
(LAST_INSERT_ID(), 'Vol. 12, No. 2', 'Science Publications', 'Technology');


INSERT INTO library_item (title, author, publish_date, status, type) VALUES
('Oxford English Dictionary', 'Oxford Press', '2020-01-01', 'BANNED', 'REFERENCE');

INSERT INTO reference (item_id, reference_type, edition, subject) VALUES 
(5, 'Dictionary', '12th Edition', 'Linguistics');


INSERT INTO library_item (title, author, publish_date, status, type, user_id, return_date) VALUES
('AI in Healthcare', 'Jane Smith', '2023-05-20', 'BORROWED', 'THESIS', 3,
 DATE_ADD(CURDATE(), INTERVAL 21 DAY));

INSERT INTO thesis (item_id, university, department, advisor) VALUES 
(LAST_INSERT_ID(), 'Stanford University', 'Computer Science', 'Dr. John Doe');


INSERT INTO history (item_id, user_id) VALUES
(1, 2),  
(1, 3),  
(3, 1),  
(5, 4);  





حالا بر اساس کوئری های خواسته شده در سند پروژه ، همه کوئری ها و نتیجه شان را قرار میدهیم:

1)کوئریهایی برای دریافت لیست تمام کتابها:
mysql>  SELECT * FROM book\G
*************************** 1. row ***************************
   item_id: 1
      isbn: 9780743273565
     genre: Fiction
page_count: 180
*************************** 2. row ***************************
   item_id: 7
      isbn: 9780061120084
     genre: Fiction
page_count: 281
2 rows in set (0.00 sec)



2)کوئریهایی برای دریافت تمام کتابهای امانت گرفته شده:

mysql> SELECT * FROM book AS b JOIN library_item AS l ON l.id = b.item_id HAVING l.type = 'BOOK' AND l.status = 'BORROWED'\G
*************************** 1. row ***************************
     item_id: 7
        isbn: 9780061120084
       genre: Fiction
  page_count: 281
          id: 7
       title: To Kill a Mockingbird
      author: Harper Lee
publish_date: 1960-07-11
      status: BORROWED
        type: BOOK
 return_date: 2025-12-28
     user_id: 1
1 row in set (0.00 sec)




3)کوئری برای دریافت تمام امانتهای یک کاربر خاص ( مثلا اینجا کاربر ۲ را انتخاب میکنیم):

mysql> SELECT id,title  FROM library_item WHERE user_id = 2\G
*************************** 1. row ***************************
   id: 8
title: Science Today
1 row in set (0.00 sec)




4)کوئری برای دریافت تاریخ بازگشت کتابها:
mysql> SELECT title,return_date FROM library_item WHERE type = 'BOOK' and return_date IS NOT NULL\G
*************************** 1. row ***************************
      title: To Kill a Mockingbird
return_date: 2025-12-28
1 row in set (0.00 sec)


5) لیست کتابهایی که بیشترین تعداد امانت را داشتهاند با تعداد امانتها:
mysql> SELECT      l.title,     COUNT(*) AS user_count FROM history AS h  JOIN library_item AS l ON l.id = h.item_id  WHERE l.type = 'BOOK' GROUP BY h.item_id,
l.title ORDER BY user_count DESC LIMIT 1
    -> \G
*************************** 1. row ***************************
     title: The Great Gatsby
user_count: 2
1 row in set (0.00 sec)



6)لیست کاربران و تعداد کتابهایی که امانت گرفته اند
mysql> SELECT COUNT(*) , u.username FROM user AS u join history as h ON h.user_id =u.id GROUP BY u.id \G
*************************** 1. row ***************************
COUNT(*): 1
username: john_doe
*************************** 2. row ***************************
COUNT(*): 1
username: jane_smith
*************************** 3. row ***************************
COUNT(*): 1
username: alice_wong
*************************** 4. row ***************************
COUNT(*): 1
username: bob_brown
4 rows in set (0.00 sec)



7)لیست کتابهای که هنوز به هیچ کاربری امانت داده نشده اند

mysql> SELECT      l.id,     l.title,     l.author,     l.publish_date,
b.isbn,     b.genre,     b.page_count FROM library_item AS l JOIN book AS b ON l.id
= b.item_id LEFT JOIN history h ON l.id = h.item_id WHERE l.type = 'BOOK'    AND l.status = 'EXIST'   AND h.id IS NULL   ORDER BY li.title\G
Empty set (0.00 sec)





8) لیست کتابها و تاریخهای بازگشت آنها برای کاربر خاص (با فیلتر بر اساس کاربر و تاریخ):
mysql> SELECT return_date FROM library_item AS l JOIN user AS u  ON u.id = l.user_id WHERE l.type = 'BOOK' and l.status = 'BORROWED'\G
*************************** 1. row ***************************
return_date: 2025-12-28
1 row in set (0.00 sec)

9)محاسبه میانگین تعداد امانتهای هر کاربر
mysql> SELECT user_id ,COUNT(*) FROM history GROUP BY user_id\G
*************************** 1. row ***************************
 user_id: 1
COUNT(*): 1
*************************** 2. row ***************************
 user_id: 2
COUNT(*): 1
*************************** 3. row ***************************
 user_id: 3
COUNT(*): 1
*************************** 4. row ***************************
 user_id: 4
COUNT(*): 1
4 rows in set (0.00 sec)


10) پیدا کردن کاربران با بیشترین تعداد امانت (با استفاده از زیرکوئری):
 mysql> SELECT user_id ,COUNT(*) AS user_count FROM history GROUP BY user_id ORDER BY user_count DESC LIMIT 1\G
*************************** 1. row ***************************
   user_id: 3
user_count: 1
1 row in set (0.00 sec)

11)لیست کتابهای امانت داده شده به کاربر خاص که تاریخ بازگشت آنها بعد از تاریخ معین است

mysql> SELECT l.title, h.borrowed_date FROM library_item AS l JOIN history AS h
ON h.user_id = l.user_id WHERE h.user_id = 2 AND h.borrowed_date > '1990-09-09'
\G
*************************** 1. row ***************************
        title: Science Today
borrowed_date: 2025-12-14 16:38:57
1 row in set (0.00 sec)


12) پیدا کردن کتابهای امانت گرفته شده که هنوز بازگشت داده نشده اند:
mysql> SELECT * FROM library_item WHERE status = 'BORROWED' AND type = 'BOOK'\G
*************************** 1. row ***************************
          id: 7
       title: To Kill a Mockingbird
      author: Harper Lee
publish_date: 1960-07-11
      status: BORROWED
        type: BOOK
 return_date: 2025-12-28
     user_id: 1
1 row in set (0.00 sec)

mysql> 



13)گزارشی از تمام کتابهایی که توسط کاربران امانت گرفته شدهاند، همراه با تاریخ امانت و تاریخ
بازگشت آنها
mysql> SELECT l.title, h.borrowed_date FROM library_item AS  l join history AS h
 ON l.id = h.item_id\G
*************************** 1. row ***************************
        title: The Great Gatsby
borrowed_date: 2025-12-14 16:38:57
*************************** 2. row ***************************
        title: The Great Gatsby
borrowed_date: 2025-12-14 16:38:57
*************************** 3. row ***************************
        title: National Geographic
borrowed_date: 2025-12-14 16:38:57
*************************** 4. row ***************************
        title: Oxford English Dictionary
borrowed_date: 2025-12-14 16:38:57
4 rows in set (0.00 sec)



با توجه به کوئریهای بالا چه ایندکس یا ایندکس هایی را برای افزایش بهره وری این پایگاه داده پیشنهاد میدهید؟ 
روی ستون هایی که کوئری زیاد زده می شود باید ایندکس گذاشت مانند آیدی در library_item 

تحقیق کنید که برای ایندکس کردن از B-tree استفاده میشود و یا  Bitmap Index؟ و برای کدوم ایندکس کردن کدام ستونهای این جداول هر کدام مناسب هستند؟
از B-tree  استفاده می شود و باید روی ستون هایی ایندکس گذاری کرد که هر عضو آن جدول را ( هر ردیف جدول را ) به صورت یکتا مشخص میکند. چون آیدی این کار را انجام میدهد پس روی آیدی ایندکس گذاری انجام میدیم.



مفهوم ACID و Transaction در پایگاه داده چیست؟ برای امانت گرفتن یک کتاب یک Transaction بنویسید که تمامی تغییرات الزم را با هم پیش ببرد و در صورت عدم موفقیت rollback کند
توضیح ACID :
حرف A به معنای اتمی بودن هست یعنی یا کل عملیات انجام میشه یا هیچ بخشی ازش انجام نمیشه و کاملا reject میشه. یعنی انجام یا عدم انجام کوئری صفر و صدی هست
حرف C: قبل و  بعد از اینکه تراکنش تموم شد دیتابیس در وضعیت نرمال و معتبری باقی میمونه و قوانین نقض نمیشه.
حرف I : به ایزوله بودن اشاره داره یعنی دو تراکنش وقتی همزمان انجام میشن روی هم اثر ندارن.
حرف D :اگر کامیت کردیم داده ها  تحت هیچ شرایطی مثل رفتن برق و ... از بین نرن و باقی بمونن.
توضیح Transaction: مجموعه ای از عملیات ها که با شرایط ACID انجام میشن و اگر کامیت کنیم همه شون اجرا میشن و در صورتی که وسطش به مشکل بخوره Roll back میشه و همه عملیات ها کنسل میشن.



START TRANSACTION;


INSERT INTO library_item (title, author, publish_date, type)
VALUES ('Sample Book', 'Unknown Author', '2024-01-01', 'BOOK');

SET @itemId = LAST_INSERT_ID();


INSERT INTO book (item_id, isbn, genre, page_count)
VALUES (@itemId, '1234567890', 'Initial Genre', 200);


UPDATE book
SET genre = 'Updated Genre'
WHERE item_id = @itemId;

COMMIT;

یک تریگر بنویسید که وقتی یک کتاب از امانت بازگشت تاریخ بازگشت آن با تریگر تصحیح شود.

CREATE TRIGGER fix_return_date_after_return
AFTER UPDATE ON library_item
FOR EACH ROW
BEGIN
   
    IF OLD.status = 'BORROWED' AND NEW.status = 'EXIST' THEN
        UPDATE library_item
        SET return_date = NULL
        WHERE id = NEW.id;
    END IF;
END;


مفهوم View چیست؟ سپس یک View برای گزارش کتابهای امانت داده شده بنویسید. از View نوشته شده خود برای نوشتن کوئری » دریافت تمام کتابهایی که تاریخ بازگشت آنها در هفته جاری هست (مثال : هفته دوم دسامبر) 

بر اساس نوعی که view دارد ممکن است کارکرد متفاوتی داشته باشد. در یک حالت یک کوئری آماده است که هروقت آن را صدا بزنیم روی دیتابیس اعمال شده و خروجی آن بازگردانده می شود( مانند متغیری که شامل یک کوئری هست) . یک حالت دیگر هم این است که روی دیتابیس اجرا می شود  و ( نتیجه ) آن ذخیره می شود که ما از آن استفاده میکنیم به جای اینکه مدام یک کوئری تکراری بزنیم . و احتمالا طبق یک سناریو در فواصل زمانی مشخص آپدیت می شود.


CREATE VIEW borrowed_books_view AS
SELECT 
    l.id AS item_id,
    l.title,
    l.author,
    l.return_date,
    l.user_id,
    u.username
FROM library_item l
JOIN user u ON l.user_id = u.id
WHERE l.status = 'BORROWED';


SELECT *
FROM borrowed_books_view
WHERE YEARWEEK(return_date, 1) = YEARWEEK(CURDATE(), 1);



تفاوت Locking Optimistic و Locking Pessimistic چیست؟ در سیستم مدیریت کتابخانه، کجا از قفل خوشبینانه (Locking Optimistic ) استفاده کنیم و کجا از قفل بدبینانه یا Locking Pessimistic؟ از هرکدام یک نمونه پیاده سازی کنید
در قفل خوشبینانه بررسی میکنیم آیا در فاصله ای که( دیتا رو دریافت کردیم و تغییر دادیم ) و سپس (میخواهیم آن تغییرات را ذخیره کنیم) آیا دیتا تغییر کرده است یا نه؟ اگر تغییر کرده باشد اجازه ذخیره داده نمیشود. اما در قفل بدبینانه هنگام تغییر و خواندن دیتا آن بخش به طور کامل قفل می شود و هیچ  کاربر دیگری نمیتواند روی آن کوئری بزند. برای مواردی مثل امانت گرفتن کتاب باید قفل بدبینانه استفاده کنیم چون ممکن است دو نفر همزمان کتاب رو امانت بگیرن اما برای مواردی که احتمالا فقط یک نفر قرار است آن را انجام دهد یا احتمال تداخل کم است مثل ویرایش اطلاعات کتاب از همان قفل خوشبینانه استفاده میکنیم.

START TRANSACTION;

-- قفل رکورد کتاب
SELECT status 
FROM library_item
WHERE id = 2
FOR UPDATE;

UPDATE library_item
SET 
    status = 'BORROWED',
WHERE id = 2;


INSERT INTO history (item_id, user_id)
VALUES (2, 3);

COMMIT;
 












