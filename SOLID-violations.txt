اصل اول :
در کلاس هایی که از LibraryItem ارث بری میکنند مانند Book ,Magazine و ... علاوه بر نگهداری اطلاعات آن کتاب مثل عنوان و ... ، نحوه چاپ اطلاعات کتاب نیز در تابع display نمایش داده شده است که اصل اول را نقض میکند. بهتر است چاپ اطلاعات در کلاس مجزایی که مربوط به نمایش اطلاعات است صورت گیرد.

همچنین در کلاس Library نیز علاوه بر نگهداری و ذخیره اطلاعات کتابخانه ، کد های مربوط به اضافه کردن کتاب و سرچ کردن بین کتاب ها و... نیز قرار دارد. حتی در بعضی از توابع نیز چاپ پیام صورت میگیرد ! در حالی ارتباط با کاربر و چاپ پیام ها همه باید در کلاس جداگانه ای انجام شود.

در کلاس CommandLineController نیز باید صرفا ارتباط با کاربر و دریافت و نمایش خروجی ها انجام شود در حالی که الان بعضی از کد های logic based نیز در این کلاس نوشته شده اند. به عنوان مثال در این کلاس در تابع addBook خالی بودن عنوان کتاب چک می شود تا در این صورت یک خطا به کاربر نمایش داده شود. اما طبق این اصل بهتر است ورودی کاربر ( فارغ از درست یا غلط بودن آن ) ابتدا به یک تابع validator از یک کلاس دیگر داده شود و بر اساس خروجی آن تابع ، در صورت نیاز پیغامی به کاربر نمایش داده شود.



اصل دوم: 
در کلاس CommandLineController برای ایجاد یک آیتم جدید از switch case استفاده می شود و بر اساس ورودی کاربر تصمیم گرفته می شود که کدام آیتم ایجاد شود ( مثلا کتاب ایجاد شود یا مجله یا ...). در این حالت اگر آیتمی جدید به انواع آیتم ها اضافه شود باید کد این کلاس آپدیت شود. 

همچنین در مواردی از کاربر خواسته می شود که وضعیت آیتم مد نظر را وارد کند. مثلا:
System.out.println("❌ Invalid status! Please choose from EXIST, BORROWED, or BANNED");
در این حالت نیز اگر وضعیت جدیدی به وضعیت های آیتم ها بخواهد اضافه شود باید محتوای بسیاری از پیغام ها عوض شود .



در کلاس هایی که از LibraryItem ارث بری میکنند نیز بر اساس فیلد هایی که دارد JsonProperty تعریف شده است که به ازای هر فیلدی که به این  کلاس ها بخواهد اضافه شود باید یک JsonProperty جدید اضافه کنیم.



اصل سوم:
 در این پروژه فقط یک مورد ارث بری استفاده شده که در آن هم هر ویژگی ای که LibraryItem دارد ، در تمامی فرزندانش وجود دارد در نتیجه میتوان فرض کرد اگر کلاس LibraryItem را با فرزندانش جایگزین کنیم مشکلی پیش نمیاید.( البته با توجه به اینکه کلاس LibraryItem به صورت abstract هست خیلی نمیتوان جایگزینی فرزندانش با این کلاس را متصور شد)




اصل چهارم :
 این اصل در رابطه با تقسیم کردن interface ها به  interface های کوچک تر می باشد اما در این پروژه هیچ interface ای استفاده نشده! در نتیجه نمیتوان گفت این اصل نقض شده ، اما عدم وجود interface خود یک ایراد بزرگ است که در ادامه هم به آن خواهیم پرداخت





اصل پنجم:
 در این پروژه در کلاس CommandLineController این اصل نقض شده. زیرا به طور مستقیم در Constructor آن یک شی از کلاس Library ساخته می شود و از آن در ادامه استفاده می شود. اما در این حالت نمیتوان از یک Library دیگر در این controller استفاده کرد . در نتیجه بهتر است یک interface برای کلاس Library تعریف کنیم طوری که Library آن را implement کند و آن interface را به کلاس Library پاس دهیم ( همان dependency injection) . 
 
